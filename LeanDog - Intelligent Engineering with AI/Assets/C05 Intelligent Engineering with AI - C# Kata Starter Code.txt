# Kata Starter Code

## Hello World

```csharp: Program.cs
namespace ConsoleApp
{
    class Program
    {
        static void Main(string[] args)
        {
            // Basic Output
            Console.WriteLine("Hello, World!");

            // Types

            // Value Types
#pragma warning disable CS0219 // Variable is assigned but its value is never used
            bool isActive = true;
            byte byteValue = 255;
            char charValue = 'A';
            decimal decimalValue = 10.5m;
            double doubleValue = 10.5;
            float floatValue = 10.5f;
            int intValue = 10;
            long longValue = 100000L;
#pragma warning restore CS0219 // Variable is assigned but its value is never used

            // Reference Types
#pragma warning disable IDE0090 // Use 'new(...)'
            object obj = new object();
#pragma warning restore IDE0090 // Use 'new(...)'
            object objSimple = new();
#pragma warning disable CS0219 // Variable is assigned but its value is never used
            string str = "Hello";
#pragma warning restore CS0219 // Variable is assigned but its value is never used

            dynamic dyn = "Dynamic typing";

            // Implicit vs Explicit typing
            var i = 10; // Implicitly typed.
            int x = 10; // Explicitly typed.
            Console.WriteLine($"i={i}, x={x}");

            // Conditionals (if)
            var isTrue = false;
            if (isTrue)
            {
                Console.WriteLine("true");
            }
            else
            {
                Console.WriteLine("false");
            }

            // Arrays, Lists, & Dictionaries
#pragma warning disable IDE0300 // Simplify collection initialization
            string[] weekDays = new string[] { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
#pragma warning restore IDE0300 // Simplify collection initialization
            string[] weekDaysSimple = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

            var optionList = new List<string> { "Option1", "Option2" };

            var cities = new Dictionary<string, string>
            {
                { "UK", "London, Manchester, Birmingham" },
                { "USA", "Chicago, New York, Washington" },
                { "India", "Mumbai, New Delhi, Pune" }
            };

            // Loops
            foreach (var kvp in cities)
            {
                Console.WriteLine($"Key: {kvp.Key}, Value: {kvp.Value}");
            }

            // Declarations & Classes
            var helloWorld = new HelloWorld { Name = "Grogu" };
            Console.WriteLine(helloWorld.Greeting());

            // Structs
            var point = new Point { X = 10, Y = 20 };
            Console.WriteLine($"Point: {point.X}, {point.Y}");

            // Enums
            var today = DaysOfWeek.Monday;
            Console.WriteLine($"Today is: {today}");

            // LINQ (Language Integrated Query)
            var numbers = new List<int> { 1, 2, 3, 4, 5 };

            // Functional Programming Examples
            // Filter: Using Where to filter even numbers
            var evenNumbers = numbers.Where(n => n % 2 == 0).ToList();
            Console.WriteLine($"Even numbers: {string.Join(", ", evenNumbers)}");

            // Find: Using FirstOrDefault to find the first even number
            var firstEven = numbers.FirstOrDefault(n => n % 2 == 0);
            Console.WriteLine($"First even number: {firstEven}");

            // Map: Using Select to square each number
            var squaredNumbers = numbers.Select(n => n * n).ToList();
            Console.WriteLine($"Squared numbers: {string.Join(", ", squaredNumbers)}");

            // Reduce: Using Aggregate to sum the numbers
            var sumOfNumbers = numbers.Aggregate((acc, n) => acc + n);
            Console.WriteLine($"Sum of numbers: {sumOfNumbers}");

            // Exception Handling
            try
            {
                int zero = 0;
                int result = 10 / zero;
            }
            catch (DivideByZeroException ex)
            {
                Console.WriteLine($"Exception caught: {ex.Message}");
            }

            // Asynchronous Programming
            AsyncDemo().Wait();

            // Null-Coalescing Operator
            string? name = null;
            string greeting = name ?? "Hello, World!";
            Console.WriteLine(greeting);

            // Null-Conditional Operators
            Console.WriteLine(name?.Length);

            // Expression-bodied Members
            var person = new Person { FirstName = "John", LastName = "Doe" };
            Console.WriteLine(person.FullName);

            // Pattern Matching
            object obj1 = 42;
            if (obj1 is int number)
            {
                Console.WriteLine($"The number is {number}");
            }
        }

        class HelloWorld
        {
            private readonly string _message = "Hello, World!";

            // Auto-Implemented Properties
            public required string Name { get; set; }

            // Expression-bodied Member
            public string Greeting() => $"{Name}\n{_message}";
        }

        // Struct Example
        struct Point
        {
            public int X { get; set; }
            public int Y { get; set; }
        }

        // Enum Example
        enum DaysOfWeek
        {
            Sunday,
            Monday,
            Tuesday,
            Wednesday,
            Thursday,
            Friday,
            Saturday
        }

        // Asynchronous Programming Example
        static async Task AsyncDemo()
        {
            await Task.Delay(1000);
            Console.WriteLine("Asynchronous Task Completed");
        }

        // Auto-Implemented Properties and Expression-bodied Member
        class Person
        {
            public required string FirstName { get; set; }
            public required string LastName { get; set; }
            public string FullName => $"{FirstName} {LastName}";
        }
    }
}
```

## FizzBuzz

```csharp: FizzBuzz.cs
namespace FizzBuzz
{
    public class FizzBuzz { }
}
```

```csharp: FizzBuzzTests.cs
/*
# Three Laws of Test Driven Development
- You are not allowed to write any production code unless it is to make a failing unit test pass.
- You are not allowed to write any more of a unit test than is sufficient to fail; and compilation failures are failures.
- You are not allowed to write any more production code than is sufficient to pass the one failing unit test.
*/

/*
PROBLEM REQUIREMENTS:
Write a program that returns a list of strings from 1 to n, where n is the upper bound.

- For multiples of three, return “Fizz” instead of the number
- For multiples of five, return “Buzz”
- For numbers which are multiples of both three and five, return “FizzBuzz“
- Otherwise, return the ordinal number (as a String)

**Upper bound**: 15
**Example output**: ['1', '2', 'Fizz', '4', 'Buzz', 'Fizz', '7', '8', 'Fizz', 'Buzz', '11', 'Fizz', '13', '14', 'FizzBuzz']
*/
using Xunit;

namespace FizzBuzz
{
    public class FizzBuzzTests
    {
        [Fact]
        public void TestFizzBuzz()
        {
            // var fizzBuzz = new FizzBuzz();
            Assert.True(false, "Turn the checked value to true to pass this test");
        }
    }
}
```

## Duration Converter

```csharp: DurationConverter.cs
namespace DurationConverter
{
    public class DurationConverter { }
}
```

```csharp: DurationConverterTests.cs
/*
# Three Laws of Test Driven Development
- You are not allowed to write any production code unless it is to make a failing unit test pass.
- You are not allowed to write any more of a unit test than is sufficient to fail; and compilation failures are failures.
- You are not allowed to write any more production code than is sufficient to pass the one failing unit test.
*/

/*
PROBLEM REQUIREMENTS:
Execution times for a program are outputted in a non-standard parseable time format.

The format is such:

- `f'{amount} {duration type}'`
- amount is a positive integer value
- duration type is an enumeration of weighted values
  - ms : .001
  - sec : 1
  - min : 60
  - hr : 3600
- different duration types are joined together with a space character
- invalid input values equal zero

Create a program, which, given a valid time format, calculates the time in seconds.
*/
using Xunit;

namespace DurationConverter
{
    public class DurationConverterTests
    {
        [Fact]
        public void TestDurationConverter()
        {
            // var DurationConverter = new DurationConverter();
            Assert.True(false, "Turn the checked value to true to pass this test");
        }
    }
}

```

## Bowling

```csharp: Bowling.cs
namespace Bowling
{
    public class Bowling { }
}
```

```csharp: BowlingTests.cs
/*
# Three Laws of Test Driven Development
- You are not allowed to write any production code unless it is to make a failing unit test pass.
- You are not allowed to write any more of a unit test than is sufficient to fail; and compilation failures are failures.
- You are not allowed to write any more production code than is sufficient to pass the one failing unit test.
*/

/*
Fake it till you make it
*/

/*
# ZOMBIES
- Z: Zero - What happens if there are zero of a thing?
- O: One - What happens when there is exactly one of a thing?
- M: Many - What happens when there are more than one thing?
- B: Boundaries - Are there special boundary values for the thing?
- I: Interfaces - Are there common interfaces with expectations?
- E: Exceptions/Errors - What cases cause errors? Exactly what should they do?
*/

/*
S - Single Responsibility Principle
O - Open / Closed => Open for extension, closed for modification
L - Liskov Substitution => shape.area :: rectangle.area : square.area : circle.area
I - Interface Segregation
D - Dependency Inversion
*/

/*
D - Don't
R - Repeat
Y - Yourself
*/

/*
Y - You
A - Ain't
G - Gonna
N - Need
I - It
*/

/*
PROBLEM REQUIREMENTS:
Create a program, which, given a valid sequence of rolls for one line of American Ten-Pin Bowling,
produces the total score for the game. Here are some things that the program will not do:

- We will not check for valid rolls.
- We will not check for correct number of rolls and frames.
- We will not provide scores for intermediate frames.

Depending on the application, this might or might not be a valid way to define a complete story,
but we do it here for purposes of keeping the kata light. I think you’ll see that improvements like
those above would go in readily if they were needed for real.

We can briefly summarize the scoring for this form of bowling:

- Each game, or “line” of bowling, includes ten turns, or “frames” for the bowler.
- In each frame, the bowler gets up to two tries to knock down all the pins.
- If in two tries, he fails to knock them all down, his score for that frame is the total number
    of pins knocked down in his two tries.
- If in two tries he knocks them all down, this is called a “spare” and his score for the frame
    is ten plus the number of pins knocked down on his next throw (in his next turn).
- If on his first try in the frame he knocks down all the pins, this is called a “strike”. His
    turn is over, and his score for the frame is ten plus the simple total of the pins knocked down
    in his next two rolls.
- If he gets a spare or strike in the last (tenth) frame, the bowler gets to throw one or two more
    bonus balls, respectively. These bonus throws are taken as part of the same turn. If the bonus throws
    knock down all the pins, the process does not repeat: the bonus throws are only used to calculate the
    score of the final frame.
- The game score is the total of all frame scores.
*/

using Xunit;

namespace Bowling
{
    public class BowlingTests
    {
        [Fact]
        public void TestBowling()
        {
            // var Bowling = new Bowling();
            Assert.True(false, "Turn the checked value to true to pass this test");
        }
    }
}
```
