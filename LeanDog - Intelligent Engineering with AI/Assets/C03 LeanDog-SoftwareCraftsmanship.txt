Certainly! Here is the formatted text from the slides:

---

**Building Great Software**

_Cardinal Commerce Training_  
_Presented by Julias Shaw_  
_January 2020_

---

### Introduction

**A Hard Truth**
Many processes, agile or otherwise, which focus on management practices and ignore development practices are doomed to failure or, at best, minor improvements. If you want to build great software products, one of the skills you must get great at is programming software!  
[See: https://www.martinfowler.com/bliki/FlaccidScrum.html]

**Software Craftsmanship** focuses on the development principles and practices that have been left behind or lost by many “agile” teams. Many of these principles and practices were originally popularized by Extreme Programming (XP) and are essential to effective DevOps.

---

### Manifesto for Agile Software Development

We are uncovering better ways of developing software by doing it and helping others do it. Through this work, we have come to value:

- **Individuals and interactions** over processes and tools
- **Working software** over comprehensive documentation
- **Customer collaboration** over contract negotiation
- **Responding to change** over following a plan

That is, while there is value in the items on the right, we value the items on the left more.

---

### Principles Behind the Agile Manifesto

1. Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.
2. Welcome changing requirements, even late in development. Agile processes harness change for the customer's competitive advantage.
3. Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale.
4. Business people and developers must work together daily throughout the project.
5. Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done.
6. The most efficient and effective method of conveying information to and within a development team is face-to-face conversation.
7. Working software is the primary measure of progress.
8. Agile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely.
9. Continuous attention to technical excellence and good design enhances agility.
10. Simplicity--the art of maximizing the amount of work not done--is essential.
11. The best architectures, requirements, and designs emerge from self-organizing teams.
12. At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly.

**Original Signatories**

- Kent Beck
- Mike Beedle
- Arie van Bennekum
- Alistair Cockburn
- Ward Cunningham
- Martin Fowler
- James Grenning
- Jim Highsmith
- Andrew Hunt
- Ron Jeffries
- Jon Kern
- Brian Marick
- Robert C. Martin
- Steve Mellor
- Ken Schwaber
- Jeff Sutherland
- Dave Thomas

These 17 people kicked off a revolution in software development (and elsewhere). Study them!

---

### Extreme Programming (XP)

**Extreme Programming (XP) Values**

- Communication
- Simplicity
- Feedback
- Courage
- Respect

**Extreme Programming (XP) Practices**

- Sit Together
- Whole Team
- Informative Workspace
- Energized Work
- Pair Programming
- Stories
- Weekly Cycle
- Quarterly Cycle
- Slack
- Ten Minute Build
- Continuous Integration
- Test-First Programming
- Incremental Design

---

### Test Driven Development (TDD)

“A software system can best be designed if the testing is interlaced with the designing instead of being used after the design.”
– Professor Alan J. Perlis, 1968 NATO Software Engineering Conference

**An Old Concept...**

“The original description of TDD was in an ancient book about programming. It said you take the input tape, manually type in the output tape you expect, then program until the actual output tape matches the expected output. After I'd written the first xUnit framework in Smalltalk I remembered reading this and tried it out. That was the origin of TDD for me. When describing TDD to older programmers, I often hear, "Of course. How else could you program?" Therefore I refer to my role as "rediscovering" TDD.”
– Kent Beck, Inventor of Extreme Programming

**Rediscovered!**

**TDD Definition**
The 3 Laws of Test Driven Development:

1. You are not allowed to write any production code unless it is to make a failing unit test pass.
2. You are not allowed to write any more of a unit test than is sufficient to fail; and compilation failures are failures.
3. You are not allowed to write any more production code than is sufficient to pass the one failing unit test.

These laws define test driven development (TDD). If you are following them you are doing TDD. If you are not following them you may be doing something good, but it is not TDD.

---

**The TDD Cycle**
During TDD you are only doing ONE of these things at a time.

1. Red
2. Green
3. Refactor

**The TDD Cycle**

- **Red** - Write a failing unit test
- **Green** - Make the test pass
- **Refactor** - Improve your code

---

### Calling Your Shots

**Calling Your Shots**
Before each time you run your test suite predict EXACTLY what result you expect to get. If you are pairing or mobbing the driver should state their prediction. After your test suite runs, examine what you can learn from each incorrect prediction.

---

### Refactoring Introduction

**Refactoring**
Refactoring is incrementally and safely improving the design of existing code without changing its functionality. Code smells tell us when to consider refactoring.

**A Few Code Smells**

- Comments
- Duplicate Code
- Misplaced Responsibility
- Unclear Name

**A Few Refactorings**

- Extract Constant
- Extract Method
- Extract Variable
- Inline
- Rename

---

### The Bowling Kata Demonstration

This is a timeless demo originally done in 1999 by Robert Martin and Bob Koss.

**Rules for Scoring Bowling**

- Each bowler plays 10 frames.
- The score for each frame is the number of pins knocked down.
- If all 10 pins are knocked down by their first ball in a frame the bowler gets 10 points plus the number of pins knocked down by their next 2 rolls. This is called a strike.
- If all 10 pins are knocked down by their second ball in a frame the bowler gets 10 points plus the number of pins knocked down by their next 1 roll. This is called a spare.
- A spare or strike in the bowler’s 10th frame will require them to roll 1 or 2 bonus balls.

**Scoring Example**

---

### Specifications

Create a class named `Game`.

The `Game` class will have two methods in it:

- `roll(pins: int)`
- `score(): int`

The `roll` method will be called whenever you roll the ball and you will pass in the number of pins you knock down. The `score` method is only called at the end of the game and it will return the score of the game. To simplify the exercise we will not consider any invalid inputs.

---

### Group Project: Design a Bowling Scorer

**Initial Design**

**Bowling Kata Demo**

---

### What did we see?

- Test Driven Development (TDD) in ruby using RSpec
- Code Smells and Refactoring (with use of IDE shortcuts)
- Simple/evolutionary design - Four classes became one conditional statement!
- Intention Revealing Code… sort of ;)
- Rapid feedback tools (Guard)

**Code Smells Identified**

- Duplicate Code
- Misplaced Responsibility
- Unclear Names
- Comments

**Refactorings Used**

- Extract Method (option-command-m)
- Extract Variable (option-command-v)
- Extract Constant (option-command-c)
- Inline (option-command-n)
- Rename (shift-F6)

**Discuss!**

---

### RSpec Introduction

**RSpec**
RSpec is a tool for writing low-level BDD tests in ruby. RSpec’s expectation and mock libraries are also used by many other tools.

**RSpec Test Structure**

- **Groups (can be nested)**: describe/context
- **Test Case**: it ‘description’ do … end
- **Disabled Group/Test**: xit/xdescribe
- **Hooks**: before(:all) {} before(:each) {} after(:each) {} after(:all) {}

**RSpec Expectations**

- expect(something).to matcher
- expect { something }.to matcher
- or
- expect(something).not_to matcher
- expect { something }.not_to matcher

**Some Built-In RSpec Matchers**

- **Equivalence**: expect(actual).to eq(expected) # passes if actual == expected
- expect(actual).to eql(expected) # passes if actual.eql?(expected)
- expect(actual).to be(expected) # identity check… passes if actual.equal?(expected)
- **Comparisons**: expect(actual).to be < expected # passes if actual < expected
- expect(actual).to be >= expected # passes if actual >= expected
- expect(actual).to be_within(delta).of(expected) # passes if actual >= (expected - delta) and actual <= (expected + delta)
- **Truthiness**: expect(actual).to be true # passes if actual == true
- expect(actual).to be falsy # passes if actual is false (false or nil)
- expect(actual).to be_nil # passes if actual is nil
- **Errors**: expect { ... }.to raise_error # passes if block raises any error
- expect { ... }.to raise_error(ErrorClass) # passes if

block raises ErrorClass

- expect { ... }.to raise_error(“message") # passes if block raises any error with “message”
- expect { ... }.to raise_error(ErrorClass, “message”) # passes if block raises ErrorClass with “message”

**RSpec Mocking** (Coming Later… when we discuss test doubles)

---

### Your Turn! FizzBuzz Kata

**Rules of FizzBuzz**
FizzBuzz is a word game to learn about division. Players count from 1 to 100 saying their number. However, if their number is divisible by 3 instead of saying the number they say Fizz, if it is divisible by 5 they say Buzz, and if it is divisible by both they say FizzBuzz.

**Getting Started**

1. Get the code: git clone git@github.com:julias-shaw/fizzbuzz_kata_ruby_starter.git
2. Install Dependencies: bundle install
3. Start Your Test Watcher: bundle exec guard

**Share & Discuss Code!**

---

### Simplicity

“Perfection is achieved, not when there is nothing more to add, but when there is nothing left to be taken away.”
–Antoine de Saint-Exupéry

**4 Laws of Simple Design**

1. Passes all tests
2. Clear, expressive, and consistent
3. Duplicates no behavior or configuration
4. Minimal modules, classes, and methods
   - Earlier rules take precedence over later rules.
   - From: Extreme Programming Explained by Kent Beck

---

### YAGNI

**Bowling Kata 2: Intention Revealing Code**

---

### Z.O.M.B.I.E. Testing!

**Z.O.M.B.I.E. Testing**

- **Z**: Zero - What happens if there are zero of a thing?
- **O**: One - What happens when there is exactly one of a thing?
- **M**: Many - What happens when there are more than one things?
- **B**: Boundaries - Are there special boundary values for the thing?
- **I**: Interfaces - Are there common interfaces with expectations?
- **E**: Exceptions/Errors - What cases cause errors? Exactly what should they do?

---

### Cucumber Introduction

**What is Cucumber?**

**Cucumber is…**
Cucumber is a tool for writing high-level BDD tests. Cucumber uses the Gherkin external DSL to write tests that can be read by non-programmers and may be implemented in many programming languages including ruby, JavaScript, Java, C#, python, clojure, elixir, PHP, etc.

**Basic Gherkin**

- Feature
- Scenario
- Given/When/Then
- @ (Tags)

**Some More Gherkin**

- Background
- Scenario/Example
- Given/When/Then/\*/And/But
- Scenario Outline/Scenario Template
- Examples
- ””” (Doc Strings)
- | (Data Tables)

---

### Outside In Development

From: https://saucelabs.com/blog/a-two-minute-bdd-overview

**It’s about Focus & Feedback**

- **Features**: Building the right thing
- **Unit Tests**: Building the thing right

---

### Pair Programming

**What is Pair Programming?**
Two people working at the same computer, fully engaged and collaborating, solving one problem.

**Ideal Setup**

- 2 people sitting side by side but slightly facing each other.
- Each person has their own screen, keyboard, and mouse.
- “Ball and Board” pairing is the exception to this.
- Both people thinking out loud.

**Pair Programming Styles**

- **Ping Pong Pairing**
- **Ball and Board**
- **Navigator Driver**

**Ping Pong Pairing Variation 1**

- **Person 1**: Write a failing unit test
- **Person 2**: Make the test pass
- **Person 1**: Refactor
- **Person 2**: Write a failing unit test
- **Person 1**: Make the test pass
- **Person 2**: Refactor

The cycle continues...

**Ping Pong Pairing Variation 2**

- **Person 1**: Write a failing unit test
- **Person 2**: Make the test pass
- **Person 1**: Refactor
- **Person 2**: Write a failing unit test
- **Person 1**: Make the test pass
- **Person 2**: Refactor

The cycle continues...

**Ball and Board**

- **Person 1**: Runs the keyboard
- **Person 2**: Runs the mouse
- Switch every 10 minutes or so

**Driver Navigator**

- The Driver runs the keyboard and the mouse. They act as an intelligent input mechanism but no more.
- The Navigator tells the driver what to do.

---

### Your Turn! Pair on Yatzy Kata

**Getting Started**

1. Get the code: git clone git@github.com:julias-shaw/yatzy_kata_ruby_starter.git
2. Install Dependencies: bundle install
3. Start Your Test Watcher: bundle exec guard

**Share & Discuss Code!**

---

### SOLID Principles

**SOLID Principles**

- **S**: Single Responsibility Principle (SRP)
- **O**: Open Closed Principle (OCP)
- **L**: Liskov Substitution Principle (LSP)
- **I**: Interface Segregation Principle (ISP)
- **D**: Dependency Inversion Principle (DIP)

**Single Responsibility Principle**
A class should have one and only one reason to change. No other class should have to change for that same reason.

**Open Closed Principle**
Software entities should be open for extension but closed for modification.

**Liskov Substitution Principle**
Subtypes must be substitutable for their base types.

**Interface Segregation Principle**
Interfaces belong to clients, not providers. Clients should not be forced to depend on methods they do not use.

**Dependency Inversion Principle**
High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend upon abstractions.

---

### Your Turn! Pair on SOLID FizzBuzz

**SOLID FizzBuzz Requirements**

1. Start with the code you wrote for the original FizzBuzz kata.
2. Refactor the code as you go along to follow SOLID principles. Pay particular attention to the Open Closed Principle (OCP).
3. Add the requirement that whenever a number is divisible by 7 you say Whiz.
4. Change the Fizz requirement so it applies if the number is divisible by 3 or if it contains a 3.

**Share & Discuss Code!**

---

### Refactoring

**24 Named Code Smells**

- Mysterious Name
- Duplicated Code
- Long Function
- Long Parameter List
- Global Data
- Mutable Data
- Divergent Change
- Shotgun Surgery
- Feature Envy
- Data Clumps
- Primitive Obsession
- Repeated Switches
- Loops
- Lazy Element
- Speculative Generality
- Temporary Field
- Message Chains
- Middle Man
- Insider Trading
- Large Class
- Alternative Classes with Different Interfaces
- Data Class
- Refused Bequest
- Comments

**Mutable Data**
Functional programming languages have taught us the dangers of mutable data which can lead to hard to predict behavior… particularly when dealing with concurrency.

**Divergent Change**
This smell occurs when one piece of code may change for multiple reasons… violating the Single Responsibility Principle.

**Shotgun Surgery**
This is the opposite of Divergent Change… Shotgun Surgery occurs when we have to make several changes in different places.

**Feature Envy**
Feature Envy occurs when a piece of code spends more time calling another piece of code than working within itself.

**Primitive Obsession**
Much of the power of strongly typed languages (and tools such as refactoring IDEs) lies in using custom types over primitive data types.

**Repeated Switches**
Seeing the same switch statement conditions repeatedly is a sign that types and polymorphism is likely a better solution.

**Loops**
Loops are a classic place for off by one errors that could often be more safely solved using iterators. Streaming iterators also have the advantage of being memory efficient even with extremely large collections.

**Speculative Generality**
This occurs when we write code to solve future needs. YAGNI!

**Refused Bequest**
This occurs when a subclass or implementor of an interface does not fulfill the entire contract of its base class or interface. This is a violation of the Liskov Substitution Principle (LSP).

**Comments**
While comments are not always bad they should always be examined to see if they could be replaced with clearer code.

---

**15 More Named Smells**

- Assertion Roulette
- Buggy Tests
- Conditional Test Logic
- Developers Not Writing Tests
- Erratic Test
- Fragile Test
- Frequent Debugging
- Hard-to-Test Code
- High Test Maintenance Cost
- Manual Intervention
- Obscure Test
- Production Bugs
- Slow Tests
- Test Code Duplication
- Test Logic in Production

_From xUnit Test Patterns: Refactoring Test Code_

---

**61 Named Refactorings!**

- Change Function Declaration
- Change Reference to Value
- Change Value to Reference
- Collapse Hierarchy
- Combine Functions into Class
- Combine Functions into Transform
- Consolidate Conditional Expression
- Decompose Conditional
- Encapsulate Collection
- Encapsulate Record
- Encapsulate Variable
- Extract Class
- Extract Function
- Extract Superclass
- Extract Variable
- Hide Delegate
- Inline Class
- Inline Function
- Inline Variable
- Introduce Assertion
- Introduce Parameter Object

- Introduce Special Case
- Move Field
- Move Function
- Move Statements into Function
- Move Statements to Callers
- Parameterize Function
- Preserve Whole Object
- Pull Up Constructor Body
- Pull Up Field
- Pull Up Method
- Push Down Field
- Push Down Method
- Remove Dead Code
- Remove Flag Argument
- Remove Middle Man
- Remove Setting Method
- Remove Subclass
- Rename Field
- Rename Variable
- Replace Command with Function
- Replace Conditional with Polymorphism
- Replace Constructor with Factory Function
- Replace Derived Variable with Query
- Replace Function with Command
- Replace Inline Code with Function Call
- Replace Loop with Pipeline
- Replace Nested Conditional with Guard Clauses
- Replace Parameter with Query
- Replace Primitive with Object
- Replace Query with Parameter
- Replace Subclass with Delegate
- Replace Superclass with Delegate
- Replace Temp with Query
- Replace Type Code with Subclasses
- Separate Query from Modifier
- Slide Statements
- Split Loop
- Split Phase
- Split Variable
- Substitute Algorithm

---

### Your Turn! Pair on Gilded Rose Kata

**Getting Started**

1. Get the code: git clone git@github.com:julias-shaw/gilded_rose_kata_ruby_starter.git
2. Install Dependencies: bundle install
3. Start Your Test Watcher: bundle exec guard

**Share & Discuss Code!**

---

### Test Doubles

**What Are Test Doubles?**
Test doubles are code that you use to stand in for part of your system to allow you to test something. Common examples of test doubles are mocks, stubs, and service stubs. People often use sloppy language and use the term “mock” to refer to any test double.

**Test Doubles**
An object that stands in for another object in your system.  
RSpec syntax:

- logger = double(“logger”)
- greeter.logger = logger
- expect(logger).to receive(:log).with(INFO, “Said: Hello, World!”)
- greeter.say_hello(“World”)

**Some rspec-mock Argument Matchers**

- expect(double).to receive(:msg).with(no_args)
- expect(double).to receive(:msg).with(any_args)
- # any args acts like an arg splat and can go anywhere
- expect(double).to receive(:msg).with(1, any_args)
- # 2nd argument can be true or false
- expect(double).to receive(:msg).with(1, boolean(), "b")
- # 2nd argument can be any String matching the submitted Regexp
- expect(double).to receive(:msg).with(1, /abc/, "b")
- # 2nd argument can be anything at all
- expect(double).to receive(:msg).with(1, anything(), "b")
- # first arg is a hash with a: 5 as one of the key-values
- expect(double).to receive(:msg).with(hash_including(:a => 5))

**Some rspec-mock Receive Counts**

- expect(double).to receive(:msg).exactly(n).time
- expect(double).to receive(:msg).exactly(n).times
- expect(double).to receive(:msg).at_least(n).time
- expect(double).to receive(:msg).at_least(n).times
- expect(double).to receive(:msg).at_most(n).time
- expect(double).to receive(:msg).at_most(n).times

**Setting rspec-mock Responses**

- # When double receives msg, it evaluates the block and returns the result.
- expect(double).to receive(:msg) { value }
- # When double receives msg, it returns value.
- expect(double).to receive(:msg).and_return(value)
- # When double receives msg, it raises error.
- expect(double).to receive(:msg).and_raise(error)

**Mock Object Example**

---

### Mob Programming

**Driver Navigator (Again)**

- The Driver runs the keyboard and the mouse. They act as an intelligent input mechanism but no more.
- Everyone else acts as a Navigator… telling the driver what to do.
- Switch to a new Driver every 10-15 minutes

**Ideal Setup**

- Driver’s Screen projected so everyone can easily see it.
- Everyone thinks out loud.

---

### Your Turn! Mob or Pair on Roman Numerals Kata

**Getting Started**

1. Get the code: git clone git@github.com:julias-shaw/roman_to_arabic_kata_ruby_starter.git
2. Install Dependencies: bundle install
3. Start Your Test Watcher: bundle exec guard

**Share & Discuss Code!**

---

### Final Rant and Q&A

---

**Stay in Touch!**
[LinkedIn](linkedin.com/in/juliasshaw/)

---

Feel free to ask if you need further modifications or additional information!
