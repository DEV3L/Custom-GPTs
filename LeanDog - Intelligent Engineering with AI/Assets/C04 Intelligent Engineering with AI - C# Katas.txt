# Intelligent Engineering with AI Katas and Practice Problem Descriptions

## C# - Hello World

This project demonstrates the basic syntax and features of the C# programming language. The `Hello, World!` example is extended to include various types, conditionals, loops, collections, LINQ, exception handling, asynchronous programming, and syntax sugar features.

### Prerequisites

- [.NET SDK](https://dotnet.microsoft.com/download) installed on your machine.

### Running the Project

This project is created using the dotnet CLI. Follow the steps below to build and run the C# file in your terminal:

```bash
~ cd HelloWorld
~ dotnet run
```

### Code Overview

Below is a detailed explanation of the features and syntax used in the `Program.cs` file:

#### Basic Output

The `Console.WriteLine` method is used to print text to the console.

```csharp
Console.WriteLine("Hello, World!");
```

#### Value Types

C# has several primitive value types, including `bool`, `byte`, `char`, `decimal`, `double`, `float`, `int`, and `long`.

```csharp
bool isActive = true;
byte byteValue = 255;
char charValue = 'A';
decimal decimalValue = 10.5m;
double doubleValue = 10.5;
float floatValue = 10.5f;
int intValue = 10;
long longValue = 100000L;
```

#### Reference Types

C# also supports reference types such as `object`, `string`, and `dynamic`.

```csharp
object obj = new object();
string str = "Hello";
dynamic dyn = "Dynamic typing";
```

#### Implicit vs Explicit Typing

You can declare variables using implicit (`var`) or explicit types.

```csharp
var i = 10; // Implicitly typed.
int x = 10; // Explicitly typed.
Console.WriteLine($"i={i}, x={x}");
```

#### Conditionals

Conditional statements in C# use `if`, `else if`, and `else`.

```csharp
var isTrue = false;
if (isTrue)
{
    Console.WriteLine("true");
}
else
{
    Console.WriteLine("false");
}
```

#### Collections: Arrays, Lists, and Dictionaries

C# supports various collection types, such as arrays, lists, and dictionaries.

```csharp
string[] weekDays = new string[] { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
var optionList = new List<string> { "Option1", "Option2" };
var cities = new Dictionary<string, string>
{
    { "UK", "London, Manchester, Birmingham" },
    { "USA", "Chicago, New York, Washington" },
    { "India", "Mumbai, New Delhi, Pune" }
};
```

#### Loops

You can iterate over collections using loops like `foreach`.

```csharp
foreach (var kvp in cities)
{
    Console.WriteLine($"Key: {kvp.Key}, Value: {kvp.Value}");
}
```

#### Classes and Objects

Classes in C# are used to create objects with properties and methods.

```csharp
var helloWorld = new HelloWorld { Name = "Grogu" };
Console.WriteLine(helloWorld.Greeting());
```

## Fizz Buzz Kata

[Fizz Buzz: Coding Dojo](http://codingdojo.org/kata/FizzBuzz)

### Problem Description

Write a program that returns a list of numbers and strings from 1 to n, where n is the upper bound.

- For multiples of three, return “Fizz” instead of the number
- For multiples of five, return “Buzz”
- For numbers which are multiples of both three and five, return “FizzBuzz“
- Otherwise, return the ordinal number

**Upper bound**: 15  
**Example output**: ['1', '2', 'Fizz', '4', 'Buzz', 'Fizz', '7', '8', 'Fizz', 'Buzz', '11', 'Fizz', '13', '14', 'FizzBuzz']

### Run

Project created using dotnet CLI.

### In the terminal, build and run the project

```bash
dotnet test
```

### TDD Cycle

1. **Red**: Write a failing test case that defines a function or feature.
2. **Green**: Write just enough code to make the test pass.
3. **Refactor**: Clean up the code, ensuring that all tests still pass.

### Tips for Using GitHub Copilot in TDD

- **Generating Test Cases**: Start by writing the test cases. Use prompts to guide Copilot to generate these test cases.
  ```csharp
  // Prompt Copilot to create test cases
  [Fact]
  public void ShouldReturnFizzForMultiplesOf3()
  {
      // Copilot will suggest code here
  }
  ```
- **Implementing Minimal Code**: After your test case is written and fails, use Copilot to suggest minimal code to make the test pass.
  ```csharp
  public string FizzBuzz(int number)
  {
      // Copilot will suggest implementation
  }
  ```
- **Refactoring with Copilot**: Use Copilot to assist in refactoring the code to improve quality while keeping all tests green.

### Tips for Using GitHub Copilot Chat Plugin in Visual Studio Code

- **Asking for Explanations**: If you are unsure about a particular piece of code, ask Copilot Chat to explain it.
  ```csharp
  // What does this method do?
  ```
- **Generating Code Snippets**: Request specific code snippets or solutions.
  ```csharp
  // Can you generate a method to check for multiples of 3 and 5?
  ```
- **Debugging Help**: Use the chat to get help on debugging issues.
  ```csharp
  // Why is my test failing?
  ```

#### Using GitHub Copilot Chat in Visual Studio Code:

1. **Open your project** in Visual Studio Code.
2. **Enable GitHub Copilot Chat**: Make sure you have the GitHub Copilot extension installed and enabled.
3. **Start a new chat session**: Use the GitHub Copilot Chat panel to ask questions or request code snippets.

#### Example Copilot Chat Prompts:

- "Explain how this code handles multiples of 3 and 5."
- "Generate a method to convert numbers into FizzBuzz format."
- "Why is my test for multiples of 3 failing?"

### Potential Questions to Ask Tyler Morgan

- **Starting with TDD**: "How should I start TDD for the FizzBuzz problem?"
- **Writing Initial Tests**: "What are some good initial test cases for the FizzBuzz problem?"
- **Using AI Tools**: "How can I effectively use GitHub Copilot to assist with writing tests for FizzBuzz?"
- **Handling Edge Cases**: "What are some edge cases I should consider when writing tests for FizzBuzz?"
- **Refactoring Tips**: "How can I refactor my FizzBuzz code to ensure it's clean and maintainable?"

## Duration Converter Kata

### Problem Description

Execution times for a program are outputted in a non-standard parseable time format.

The format is such:

- `f'{amount} {duration type}'`
- amount is a positive integer value
- duration type is an enumeration of weighted values
  - ms : .001
  - sec : 1
  - min : 60
  - hr : 3600
- different duration types are joined together with a space character
- invalid input values equal zero

Create a program, which, given a valid time format, calculates the time in seconds.

**Examples:**

| Input Value               | Expected Result |
| ------------------------- | --------------- |
| '1 ms'                    | .001            |
| '1 sec'                   | 1               |
| '1 min'                   | 60              |
| '1 hr'                    | 3600            |
| '5 sec 421 ms'            | 5.421           |
| '9 min 57 sec'            | 597             |
| '1 hr 33 min'             | 5580            |
| '1 hr 1 min 1 sec 111 ms' | 3661.111        |
| ''                        | 0               |

### Run

Project created using dotnet CLI.

### In the terminal, build and run the project

```bash
dotnet test
```

### TDD Cycle

1. **Red**: Write a failing test case that defines a function or feature.
2. **Green**: Write just enough code to make the test pass.
3. **Refactor**: Clean up the code, ensuring that all tests still pass.

### Tips for Using GitHub Copilot in TDD

- **Generating Test Cases**: Start by writing the test cases. Use prompts to guide Copilot to generate these test cases.
  ```csharp
  // Prompt Copilot to create test cases
  [Fact]
  public void ShouldReturnMillisecondsFor1Ms()
  {
      // Copilot will suggest code here
  }
  ```
- **Implementing Minimal Code**: After your test case is written and fails, use Copilot to suggest minimal code to make the test pass.
  ```csharp
  public double ParseTime(string time)
  {
      // Copilot will suggest implementation
  }
  ```
- **Refactoring with Copilot**: Use Copilot to assist in refactoring the code to improve quality while keeping all tests green.

### Tips for Using GitHub Copilot Chat Plugin in Visual Studio Code

- **Asking for Explanations**: If you are unsure about a particular piece of code, ask Copilot Chat to explain it.
  ```csharp
  // What does this method do?
  ```
- **Generating Code Snippets**: Request specific code snippets or solutions.
  ```csharp
  // Can you generate a method to parse different time formats?
  ```
- **Debugging Help**: Use the chat to get help on debugging issues.
  ```csharp
  // Why is my test failing?
  ```

#### Using GitHub Copilot Chat in Visual Studio Code:

1. **Open your project** in Visual Studio Code.
2. **Enable GitHub Copilot Chat**: Make sure you have the GitHub Copilot extension installed and enabled.
3. **Start a new chat session**: Use the GitHub Copilot Chat panel to ask questions or request code snippets.

#### Example Copilot Chat Prompts:

- "Explain how this code parses time strings."
- "Generate a method to convert '1 hr 33 min' into seconds."
- "Why am I getting a format exception in my test?"

### Potential Questions to Ask Tyler Morgan

- **Starting with TDD**: "How should I start TDD for the Duration Converter Kata problem?"
- **Writing Initial Tests**: "What are some good initial test cases for the Duration Converter Kata problem?"
- **Using AI Tools**: "How can I effectively use GitHub Copilot to assist with writing tests for Duration Converter Kata?"
- **Handling Edge Cases**: "What are some edge cases I should consider when writing tests for Duration Converter Kata?"
- **Refactoring Tips**: "How can I refactor my Duration Converter Kata code to ensure it's clean and maintainable?"

## Bowling Kata

### Problem Description

Create a program, which, given a valid sequence of rolls for one line of American Ten-Pin Bowling, produces the total score for the game. Here are some things that the program will not do:

- We will not check for valid rolls.
- We will not check for the correct number of rolls and frames.
- We will not provide scores for intermediate frames.

Depending on the application, this might or might not be a valid way to define a complete story, but we do it here for the purposes of keeping the kata light. I think you’ll see that improvements like those above would go in readily if they were needed for real.

We can briefly summarize the scoring for this form of bowling:

- Each game, or “line” of bowling, includes ten turns, or “frames” for the bowler.
- In each frame, the bowler gets up to two tries to knock down all the pins.
- If in two tries, they fail to knock them all down, the score for that frame is the total number of pins knocked down in their two tries.
- If in two tries they knock them all down, this is called a “spare” and the score for the frame is ten plus the number of pins knocked down on their next throw (in their next turn).
- If on the first try in the frame they knock down all the pins, this is called a “strike”. Their turn is over, and the score for the frame is ten plus the simple total of the pins knocked down in their next two rolls.
- If they get a spare or strike in the last (tenth) frame, the bowler gets to throw one or two more bonus balls, respectively. These bonus throws are taken as part of the same turn. If the bonus throws knock down all the pins, the process does not repeat: the bonus throws are only used to calculate the score of the final frame.
- The game score is the total of all frame scores.

More info on the rules at: [How to Score for Bowling](https://www.topendsports.com/sport/tenpin/scoring.htm)

### Clues

What makes this game interesting to score is the lookahead in the scoring for strikes and spares. At the time we throw a strike or spare, we cannot calculate the frame score: we have to wait one or two frames to find out what the bonus is.

### Suggested Test Cases

_(When scoring, “X” indicates a strike, “/” indicates a spare, “-” indicates a miss)_

- `X X X X X X X X X X X X` (12 rolls: 12 strikes) = 10 frames \* 30 points = 300
- `9- 9- 9- 9- 9- 9- 9- 9- 9- 9-` (20 rolls: 10 pairs of 9 and miss) = 10 frames \* 9 points = 90
- `5/ 5/ 5/ 5/ 5/ 5/ 5/ 5/ 5/ 5/5` (21 rolls: 10 pairs of 5 and spare, with a final 5) = 10 frames \* 15 points = 150

### Run

Project created using dotnet CLI.

### In the terminal, build and run the project

```bash
dotnet test
```

### TDD Cycle

1. **Red**: Write a failing test case that defines a function or feature.
2. **Green**: Write just enough code to make the test pass.
3. **Refactor**: Clean up the code, ensuring that all tests still pass.

### Fake it till you make it

Start with the simplest solution that could possibly work, even if it is just hardcoding the answer. Gradually replace hardcoded parts with real logic as more tests are added and pass.

### ZOMBIES

Use the ZOMBIES acronym to guide your test cases:

- **Z: Zero** - What happens if there are zero of a thing?
- **O: One** - What happens when there is exactly one of a thing?
- **M: Many** - What happens when there are more than one thing?
- **B: Boundaries** - Are there special boundary values for the thing?
- **I: Interfaces** - Are there common interfaces with expectations?
- **E: Exceptions/Errors** - What cases cause errors? Exactly what should they do?

### SOLID Principles

Follow the SOLID principles to create maintainable and scalable code:

- **S: Single Responsibility Principle** - A class should have one and only one reason to change.
- **O: Open/Closed Principle** - Software entities should be open for extension, but closed for modification.
- **L: Liskov Substitution Principle** - Objects of a superclass should be replaceable with objects of its subclasses without breaking the application.
- **I: Interface Segregation Principle** - No client should be forced to depend on methods it does not use.
- **D: Dependency Inversion Principle** - High-level modules should not depend on low-level modules. Both should depend on abstractions.

### DRY - Don't Repeat Yourself

Avoid duplication. Each piece of knowledge must have a single, unambiguous, authoritative representation within a system.

### YAGNI - You Ain't Gonna Need It

Implement only what is necessary. Don’t add functionality until it is deemed necessary.

### Tips for Using GitHub Copilot in TDD

- **Generating Test Cases**: Start by writing the test cases. Use prompts to guide Copilot to generate these test cases.
  ```csharp
  // Prompt Copilot to create test cases
  [Fact]
  public void ShouldReturnPerfectScoreForAllStrikes()
  {
      // Copilot will suggest code here
  }
  ```
- **Implementing Minimal Code**: After your test case is written and fails, use Copilot to suggest minimal code to make the test pass.
  ```csharp
  public int CalculateScore(string rolls)
  {
      // Copilot will suggest implementation
  }
  ```
- **Refactoring with Copilot**: Use Copilot to assist in refactoring the code to improve quality while keeping all tests green.

### Tips for Using GitHub Copilot Chat Plugin in Visual Studio Code

- **Asking for Explanations**: If you are unsure about a particular piece of code, ask Copilot Chat to explain it.
  ```csharp
  // What does this method do?
  ```
- **Generating Code Snippets**: Request specific code snippets or solutions.
  ```csharp
  // Can you generate a method to calculate the score for a sequence of rolls?
  ```
- **Debugging Help**: Use the chat to get help on debugging issues.
  ```csharp
  // Why is my test failing?
  ```

#### Using GitHub Copilot Chat in Visual Studio Code:

1. **Open your project** in Visual Studio Code.
2. **Enable GitHub Copilot Chat**: Make sure you have the GitHub Copilot extension installed and enabled.
3. **Start a new chat session**: Use the GitHub Copilot Chat panel to ask questions or request code snippets.

#### Example Copilot Chat Prompts:

- "Explain how this code calculates the score for a bowling game."
- "Generate a method to handle spares in a bowling game."
- "Why am I getting an incorrect score for my bowling game?"

### Potential Questions to Ask Tyler Morgan

- **Starting with TDD**: "How should I start TDD for the Bowling Kata problem?"
- **Writing Initial Tests**: "What are some good initial test cases for the Bowling Kata problem?"
- **Using AI Tools**: "How can I effectively use GitHub Copilot to assist with writing tests for the Bowling Kata?"
- **Handling Edge Cases**: "What are some edge cases I should consider when writing tests for the Bowling Kata?"
- **Refactoring Tips**: "How can I refactor my Bowling Kata code to ensure it's clean and maintainable?"
